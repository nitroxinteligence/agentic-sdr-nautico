#!/usr/bin/env python3
"""
Script de limpeza imediata para resolver os n√∫meros inv√°lidos
FOCO: Limpar dados corrompidos do banco (que √© a causa raiz)
"""
import asyncio
import os
import sys
from datetime import datetime

# Adicionar o path do projeto
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from app.integrations.supabase_client import supabase_client
from app.utils.logger import emoji_logger


def validate_phone_number(phone: str) -> bool:
    """Valida se um n√∫mero de telefone √© v√°lido"""
    if not phone:
        return False
    
    # N√∫meros que come√ßam com 'unknown_' s√£o definitivamente inv√°lidos
    if phone.startswith('unknown_'):
        return False
    
    digits_only = ''.join(filter(str.isdigit, phone))
    
    if len(digits_only) < 10 or len(digits_only) > 15:
        return False
    
    if len(set(digits_only)) < 3:
        return False
    
    if digits_only.startswith('55') and len(digits_only) < 12:
        return False
    
    return True


async def find_and_clean_invalid_leads(dry_run: bool = True):
    """Encontra e limpa leads com n√∫meros inv√°lidos"""
    
    print("üîç Buscando leads com n√∫meros inv√°lidos...")
    
    try:
        # Buscar todos os leads
        result = supabase_client.client.table('leads').select('*').execute()
        leads = result.data
        
        invalid_leads = []
        for lead in leads:
            phone = lead.get('phone_number', '')
            if phone and not validate_phone_number(phone):
                invalid_leads.append(lead)
                name = lead.get('name', 'Sem nome')
                print(f"‚ùå Lead inv√°lido: {name} -> '{phone}' (ID: {lead['id']})")
        
        print(f"\nüìä Encontrados {len(invalid_leads)} leads com n√∫meros inv√°lidos")
        
        if invalid_leads and not dry_run:
            print("üßπ Iniciando limpeza...")
            
            cleaned = 0
            for lead in invalid_leads:
                try:
                    # DELETAR o lead completamente (n√∫meros unknown s√£o lixo)
                    supabase_client.client.table('leads').delete().eq('id', lead['id']).execute()
                    print(f"‚úÖ Lead deletado: {lead.get('name', 'Sem nome')} (ID: {lead['id']})")
                    cleaned += 1
                except Exception as e:
                    print(f"‚ùå Erro ao deletar lead {lead['id']}: {e}")
            
            print(f"\n‚úÖ Limpeza conclu√≠da: {cleaned} leads removidos")
        
        return len(invalid_leads)
        
    except Exception as e:
        print(f"‚ùå Erro ao processar leads: {e}")
        return 0


async def find_and_clean_invalid_conversations(dry_run: bool = True):
    """Encontra e limpa conversas com n√∫meros inv√°lidos"""
    
    print("\nüîç Buscando conversas com n√∫meros inv√°lidos...")
    
    try:
        # Buscar todas as conversas
        result = supabase_client.client.table('conversations').select('*').execute()
        conversations = result.data
        
        invalid_conversations = []
        for conv in conversations:
            phone = conv.get('phone_number', '')
            if phone and not validate_phone_number(phone):
                invalid_conversations.append(conv)
                print(f"‚ùå Conversa inv√°lida: '{phone}' (ID: {conv['id']})")
        
        print(f"\nüìä Encontradas {len(invalid_conversations)} conversas com n√∫meros inv√°lidos")
        
        if invalid_conversations and not dry_run:
            print("üßπ Iniciando limpeza...")
            
            cleaned = 0
            for conv in invalid_conversations:
                try:
                    # DELETAR a conversa completamente
                    supabase_client.client.table('conversations').delete().eq('id', conv['id']).execute()
                    print(f"‚úÖ Conversa deletada: {conv['phone_number']} (ID: {conv['id']})")
                    cleaned += 1
                except Exception as e:
                    print(f"‚ùå Erro ao deletar conversa {conv['id']}: {e}")
            
            print(f"\n‚úÖ Limpeza conclu√≠da: {cleaned} conversas removidas")
        
        return len(invalid_conversations)
        
    except Exception as e:
        print(f"‚ùå Erro ao processar conversas: {e}")
        return 0


async def find_and_clean_invalid_followups(dry_run: bool = True):
    """Encontra e limpa follow-ups com n√∫meros inv√°lidos"""
    
    print("\nüîç Buscando follow-ups com n√∫meros inv√°lidos...")
    
    try:
        # Buscar todos os follow-ups
        result = supabase_client.client.table('follow_ups').select('*').execute()
        followups = result.data
        
        invalid_followups = []
        for followup in followups:
            phone = followup.get('phone_number', '')
            if phone and not validate_phone_number(phone):
                invalid_followups.append(followup)
                status = followup.get('status', 'unknown')
                print(f"‚ùå Follow-up inv√°lido: '{phone}' -> Status: {status} (ID: {followup['id']})")
        
        print(f"\nüìä Encontrados {len(invalid_followups)} follow-ups com n√∫meros inv√°lidos")
        
        if invalid_followups and not dry_run:
            print("üßπ Iniciando limpeza...")
            
            cleaned = 0
            for followup in invalid_followups:
                try:
                    if followup.get('status') in ['pending', 'queued']:
                        # Cancelar follow-ups pendentes
                        supabase_client.client.table('follow_ups').update({
                            'status': 'cancelled',
                            'error_reason': f"N√∫mero inv√°lido removido: {followup.get('phone_number')}",
                            'updated_at': datetime.now().isoformat()
                        }).eq('id', followup['id']).execute()
                        print(f"‚úÖ Follow-up cancelado: {followup['id']}")
                    else:
                        # Deletar follow-ups j√° processados
                        supabase_client.client.table('follow_ups').delete().eq('id', followup['id']).execute()
                        print(f"‚úÖ Follow-up deletado: {followup['id']}")
                    
                    cleaned += 1
                except Exception as e:
                    print(f"‚ùå Erro ao limpar follow-up {followup['id']}: {e}")
            
            print(f"\n‚úÖ Limpeza conclu√≠da: {cleaned} follow-ups processados")
        
        return len(invalid_followups)
        
    except Exception as e:
        print(f"‚ùå Erro ao processar follow-ups: {e}")
        return 0


async def search_specific_number():
    """Busca especificamente pelo n√∫mero problem√°tico 238443732942898"""
    
    print("\nüéØ BUSCA ESPEC√çFICA PELO N√öMERO 238443732942898:")
    
    found_items = []
    
    try:
        # Buscar em leads
        result = supabase_client.client.table('leads').select('*').execute()
        for lead in result.data:
            phone = lead.get('phone_number', '')
            if '238443732942898' in str(phone):
                print(f"üö® ENCONTRADO EM LEADS: {lead.get('name')} -> '{phone}' (ID: {lead['id']})")
                found_items.append(('leads', lead['id'], phone))
        
        # Buscar em conversations
        result = supabase_client.client.table('conversations').select('*').execute()
        for conv in result.data:
            phone = conv.get('phone_number', '')
            if '238443732942898' in str(phone):
                print(f"üö® ENCONTRADO EM CONVERSATIONS: '{phone}' (ID: {conv['id']})")
                found_items.append(('conversations', conv['id'], phone))
        
        # Buscar em follow_ups
        result = supabase_client.client.table('follow_ups').select('*').execute()
        for followup in result.data:
            phone = followup.get('phone_number', '')
            if '238443732942898' in str(phone):
                print(f"üö® ENCONTRADO EM FOLLOW_UPS: '{phone}' -> Status: {followup.get('status')} (ID: {followup['id']})")
                found_items.append(('follow_ups', followup['id'], phone))
        
        if not found_items:
            print("‚úÖ N√∫mero problem√°tico 238443732942898 N√ÉO encontrado no banco!")
        else:
            print(f"\nüö® TOTAL: {len(found_items)} ocorr√™ncias do n√∫mero problem√°tico encontradas")
        
        return found_items
        
    except Exception as e:
        print(f"‚ùå Erro na busca espec√≠fica: {e}")
        return []


async def main():
    """Fun√ß√£o principal de limpeza imediata"""
    
    print("üö® LIMPEZA IMEDIATA DE DADOS CORROMPIDOS")
    print("=" * 60)
    
    # Verificar se √© dry-run ou execu√ß√£o real
    dry_run = '--execute' not in sys.argv
    
    if dry_run:
        print("‚ö†Ô∏è  MODO AN√ÅLISE: Identificando problemas sem fazer altera√ß√µes")
        print("   Para executar as corre√ß√µes, use: python immediate_cleanup.py --execute")
    else:
        print("üö® MODO EXECU√á√ÉO: DADOS SER√ÉO DELETADOS!")
        confirm = input("Tem certeza que deseja continuar? (digite 'SIM' para confirmar): ")
        if confirm != 'SIM':
            print("‚ùå Opera√ß√£o cancelada pelo usu√°rio")
            return
    
    # Busca espec√≠fica primeiro
    await search_specific_number()
    
    # An√°lise geral
    invalid_leads = await find_and_clean_invalid_leads(dry_run)
    invalid_conversations = await find_and_clean_invalid_conversations(dry_run)
    invalid_followups = await find_and_clean_invalid_followups(dry_run)
    
    # Resumo
    total_invalid = invalid_leads + invalid_conversations + invalid_followups
    
    print(f"\n" + "=" * 60)
    print(f"üìä RESUMO FINAL:")
    print(f"   Leads inv√°lidos: {invalid_leads}")
    print(f"   Conversas inv√°lidas: {invalid_conversations}")
    print(f"   Follow-ups inv√°lidos: {invalid_followups}")
    print(f"   TOTAL DE ITENS INV√ÅLIDOS: {total_invalid}")
    
    if dry_run and total_invalid > 0:
        print(f"\nüí° Para executar a limpeza, rode:")
        print(f"   python immediate_cleanup.py --execute")
    elif not dry_run:
        print(f"\n‚úÖ Limpeza executada com sucesso!")
        print(f"   Agora teste enviando uma mensagem nova")
    elif total_invalid == 0:
        print(f"\nüéâ Nenhum dado inv√°lido encontrado!")
        print(f"   O problema pode estar no cache Redis ou em outra parte")
    
    print("=" * 60)


if __name__ == "__main__":
    asyncio.run(main())